import sys, json, asyncio, threading
from PyQt6.QtWidgets import (QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QFrame, QSizeGrip)
from PyQt6.QtCore import Qt, pyqtSignal, QPoint
import websockets
from editor import ColorEditor
from settings_gui import GeneralSettings


import json

def load_json(filename, default):
    try:
        with open(filename, 'r') as f:
            return json.load(f)
    except:
        return default

# Load your data once at startup
JOB_COLORS = load_json('colors.json', {"default": "#555555"})
USER_CONFIG = load_json('config.json', {
    "damage%": True, 
    "DirectHitPct": True, 
    "crithit%": True, 
    "deaths": True
})


def load_job_colors():
    try:
        with open('colors.json', 'r') as f:
            return json.load(f)
    except Exception:
        return {"default": "#555555"}

# Initial load
JOB_COLORS = load_job_colors()



# Load them into a global variable
JOB_COLORS = load_job_colors()

class PlayerRow(QFrame):
    def __init__(self, p_data, dps, job, top_dps, colors, config):
        super().__init__()
        # 1. Prevent clicks from stealing focus from the game
        self.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents)
        
        layout = QHBoxLayout(self)
        layout.setContentsMargins(8, 2, 8, 2)
        layout.setSpacing(10)
        
        # 2. Get the Job Color from your external colors.json
        job_key = job.lower()
        color = colors.get(job_key, colors.get("default", "#555555"))
        
        # 3. Apply the visual style (Role-colored bar)
        self.setStyleSheet(f"""
            QFrame {{
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0, 
                            stop:0 {color}, stop:0.8 {color}, 
                            stop:0.81 rgba(30,30,30,150), stop:1 rgba(30,30,30,150));
                border-radius: 3px;
                min-height: 26px;
            }}
            QLabel {{ color: white; font-family: 'Ubuntu', 'Segoe UI'; font-size: 11px; font-weight: bold; }}
        """)
    
        # 1. Name
        name_lbl = QLabel(p_data.get('name', '??'))
        layout.addWidget(name_lbl)
        layout.addStretch()

        # 2. Dynamic Stats (MUST follow the same loop order as HeaderRow)
        for key, enabled in config.items():
            if enabled:
                val = p_data.get(key, '0')
                # Remove % if it's already in the string to keep it clean
                clean_val = str(val).replace('%', '')
                
                stat_lbl = QLabel(clean_val)
                stat_lbl.setFixedWidth(40) # MUST MATCH HEADER
                stat_lbl.setAlignment(Qt.AlignmentFlag.AlignCenter)
                layout.addWidget(stat_lbl)

        # 3. DPS
        dps_lbl = QLabel(f"{float(dps):.0f}")
        dps_lbl.setFixedWidth(50) # MUST MATCH HEADER
        dps_lbl.setAlignment(Qt.AlignmentFlag.AlignRight)
        layout.addWidget(dps_lbl)

class HeaderRow(QWidget):
    def __init__(self, config):
        super().__init__()
        layout = QHBoxLayout(self)
        layout.setContentsMargins(10, 2, 10, 2)
        layout.setSpacing(10)
        
        self.setStyleSheet("QLabel { color: #666; font-size: 9px; font-weight: bold; }")

        # 1. PLAYER column
        self.player_lbl = QLabel("PLAYER")
        layout.addWidget(self.player_lbl)
        layout.addStretch()

        # 2. Dynamic Columns
        for key, enabled in config.items():
            if enabled:
                # Map technical names to pretty headers
                display = "DH" if "Direct" in key else "CRT" if "crit" in key else "DMG%" if "damage" in key else "D" if "deaths" in key else key
                lbl = QLabel(display)
                lbl.setFixedWidth(40) # MATCH THIS WITH PLAYER ROW
                lbl.setAlignment(Qt.AlignmentFlag.AlignCenter)
                layout.addWidget(lbl)

        # 3. DPS column
        self.dps_lbl = QLabel("DPS")
        self.dps_lbl.setFixedWidth(50) # MATCH THIS WITH PLAYER ROW
        self.dps_lbl.setAlignment(Qt.AlignmentFlag.AlignRight)
        layout.addWidget(self.dps_lbl)

class Overlay(QWidget):
    data_signal = pyqtSignal(dict)
    def __init__(self):
        super().__init__()
        # 1. Window Setup
        self.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.WindowStaysOnTopHint | Qt.WindowType.X11BypassWindowManagerHint | Qt.WindowType.SubWindow)
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        
        # 2. Main Outer Layout (The Stack)
        self.outer_layout = QVBoxLayout(self)
        self.outer_layout.setContentsMargins(0, 0, 0, 0)
        self.outer_layout.setSpacing(0)

        # 3. Create the Title Bar
        self.title_bar = QFrame()
        self.title_bar.setFixedHeight(24)
        self.title_bar.setStyleSheet("background: rgba(40, 40, 40, 100); border-top-left-radius: 8px; border-top-right-radius: 8px;")
        title_layout = QHBoxLayout(self.title_bar)
        title_layout.setContentsMargins(5, 0, 5, 0)
        
        # Add Buttons to Title Bar
        self.btn_settings = self._create_btn("âš™", "#888", self.open_definitions)
        self.btn_stats = self._create_btn("ðŸ“Š", "#888", self.open_stats_config)
        self.handle_label = QLabel("FFXIV Tracker")
        self.handle_label.setStyleSheet("color: #666; font-size: 10px; font-weight: bold;")
        
        title_layout.addWidget(self.btn_settings)
        title_layout.addWidget(self.btn_stats)
        title_layout.addWidget(self.handle_label)
        title_layout.addStretch()
        
        title_layout.addWidget(self._create_btn("-", "#ffbd2e", self.showMinimized))
        title_layout.addWidget(self._create_btn("â–¡", "#27c93f", self._toggle_max))
        title_layout.addWidget(self._create_btn("Ã—", "#ff5f56", self.close))

        # 4. Create the Header Row (Subtitles)
        self.header_row = HeaderRow(USER_CONFIG)

        # 5. Create the Main Content Area (Where players appear)
        self.container = QFrame()
        self.container.setStyleSheet("background-color: rgba(10, 10, 10, 180); border-bottom-left-radius: 8px; border-bottom-right-radius: 8px;")
        self.main_layout = QVBoxLayout(self.container)
        self.main_layout.setContentsMargins(6, 6, 6, 6)
        self.main_layout.setSpacing(4)

        # 6. Add everything to the Outer Layout in order
        self.outer_layout.addWidget(self.title_bar)   # Top
        self.outer_layout.addWidget(self.header_row)  # Subtitles
        self.outer_layout.addWidget(self.container)   # Players list

        # Status Label inside the main layout
        self.status_label = QLabel("IINACT Connected")
        self.status_label.setStyleSheet("color: #888; font-size: 10px; border: none;")
        self.main_layout.addWidget(self.status_label)

        # 7. Final Setup
        self.sizegrip = QSizeGrip(self)
        self.setGeometry(200, 200, 350, 250) # Made it slightly wider for columns
        self.data_signal.connect(self.update_ui)
        self.show()

    def _create_btn(self, text, color, func):
        btn = QLabel(text)
        btn.setFixedSize(16, 16)
        btn.setAlignment(Qt.AlignmentFlag.AlignCenter)
        btn.setStyleSheet(f"""
            QLabel {{ 
                background: {color}; color: black; border-radius: 8px; 
                font-family: Arial; font-weight: bold; font-size: 10px;
            }}
            QLabel:hover {{ background: white; }}
        """)
        # This makes the label act like a button
        btn.mousePressEvent = lambda e: func()
        return btn

    def _toggle_max(self):
        if self.isMaximized():
            self.showNormal()
        else:
            self.showMaximized()

    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton:
            # This is the "Magic Line" for Linux/Wayland
            # It tells the OS to start the native window-drag operation
            self.windowHandle().startSystemMove()
            event.accept()

    def resizeEvent(self, event):
        self.sizegrip.move(self.width() - 16, self.height() - 16)
        super().resizeEvent(event)

    def update_ui(self, data):
        global JOB_COLORS
        if data.get('msgtype') != 'CombatData': return
        msg_data = data.get('msg', {})
        if not isinstance(msg_data, dict): return
        combatants = msg_data.get('Combatant', {})

        # Clear old rows
        for i in reversed(range(self.main_layout.count())):
            item = self.main_layout.itemAt(i)
            if item and item.widget():
                w = item.widget()
                if isinstance(w, PlayerRow):
                    w.setParent(None)
                    w.deleteLater()

        if not combatants:
            # RELOAD COLORS HERE: Every time combat ends/waits
            JOB_COLORS = load_job_colors()
            self.status_label.setText("Waiting for Combat...")
            self.status_label.show()
            return
        
        self.status_label.hide()

        # Get top DPS for scaling
        def get_dps(p):
            try: return float(str(p.get('encdps', 0)).replace('âˆž', '0'))
            except: return 0.0

        players = sorted(combatants.values(), key=get_dps, reverse=True)[:10]
        top_dps = get_dps(players[0]) if players else 1.0

        for p in players:
            d_val = get_dps(p)
            if d_val > 0:
                # PlayerRow now uses the refreshed JOB_COLORS
                self.main_layout.addWidget(
                    PlayerRow(
                        p,              # Send the whole player dict for dynamic stats
                        d_val,          # Current DPS
                        p.get('Job', 'any'), 
                        top_dps, 
                        JOB_COLORS,     # Added this
                        USER_CONFIG     # Added this
                    )
                )        

    def open_definitions(self):
        # Check if editor already exists to avoid multiple windows
        if not hasattr(self, 'editor') or not self.editor.isVisible():
            self.editor = ColorEditor(JOB_COLORS, self.update_colors_instantly)
            self.editor.show()

    def update_colors_instantly(self, new_colors):
        global JOB_COLORS
        JOB_COLORS = new_colors
        # The next time update_ui runs (next combat tick), it uses these
    
    def open_stats_config(self):
        if not hasattr(self, 'stats_window') or not self.stats_window.isVisible():
            self.stats_window = GeneralSettings(USER_CONFIG, self.update_config_instantly)
            self.stats_window.show()

    def update_config_instantly(self, new_config):
        global USER_CONFIG
        USER_CONFIG = new_config
        
        # Remove old header
        self.header_row.setParent(None)
        self.header_row.deleteLater()
        
        # Create and insert new header at index 1 (between title and container)
        self.header_row = HeaderRow(USER_CONFIG)
        self.outer_layout.insertWidget(1, self.header_row)


async def socket_client(window):
    uri = "ws://127.0.0.1:10501/MiniParse"
    while True:
        try:
            async with websockets.connect(uri, ping_interval=None) as ws:
                await ws.send(json.dumps({"type": "subscribe", "events": ["CombatData"]}))
                while True:
                    msg = await ws.recv()
                    window.data_signal.emit(json.loads(msg))
        except:
            await asyncio.sleep(2)

if __name__ == '__main__':
    app = QApplication(sys.argv)

    app.setQuitOnLastWindowClosed(False)

    window = Overlay()
    loop = asyncio.new_event_loop()
    threading.Thread(target=lambda: loop.run_until_complete(socket_client(window)), daemon=True).start()
    sys.exit(app.exec())
